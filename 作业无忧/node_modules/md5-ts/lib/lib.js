export function split(target, step, markString) {
    if (markString === void 0) { markString = typeof target === 'string'; }
    if (typeof target === 'string')
        target = target.split('');
    var result = target
        .map(function (_, index) {
        return index % step === 0
            ? Array.from(Array(step).keys()).map(function (x) { return target[index + x]; })
            : [];
    })
        .filter(function (x) { return x.length > 0; });
    if (markString)
        result = result.map(function (x) { return x.join(''); });
    return result;
}
export function padding(str, length, char, tail, isArray) {
    if (tail === void 0) { tail = true; }
    if (isArray === void 0) { isArray = Array.isArray(str); }
    var arr;
    if (Array.isArray(str)) {
        arr = str;
    }
    else {
        arr = str.split('');
    }
    var paddingStr = range(length - str.length).map(function () { return char; });
    var result = tail ? arr.concat(paddingStr) : paddingStr.concat(arr);
    return isArray ? result : result.join('');
}
export function little_endian(charCode) {
    return split(padding(charCode.toString(16), 8, '0', false), 2)
        .reverse()
        .join('');
}
export function range() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var start = args.length === 1 ? 0 : args[0];
    var end = args.length === 2 ? args[1] : args[0] - 1;
    return Array.from(Array(end - start + 1).keys()).map(function (x) { return x + start; });
}
export function to_binary(code, bit, max) {
    if (bit === void 0) { bit = 8; }
    if (max === void 0) { max = Math.pow(2, bit) - 1; }
    if (code < 0)
        throw new Error('code should be greater than: 0');
    if (code > max)
        throw new Error('code should be less than: ' + max);
    return padding(code.toString(2), bit, '0', false);
}
export function to_hex(code, bit, max) {
    if (bit === void 0) { bit = 8; }
    if (max === void 0) { max = Math.pow(16, bit) - 1; }
    if (code < 0)
        throw new Error('code should be greater than: 0');
    if (code > max)
        throw new Error('code should be less than: ' + max);
    return padding(code.toString(16), bit, '0', false);
}
export function to_code(str) {
    if (str.substr(0, 2).toLowerCase() === '0b')
        return parseInt(str.substr(2, 8), 2);
    if (str.substr(0, 2).toLowerCase() === '0x')
        return parseInt(str.substr(2, 8), 16);
}
export function utf16_to_utf8(str) {
    return str
        .split('')
        .map(function (char) { return utf8_encode(char); })
        .join('');
}
export function utf8_encode(char) {
    var utftext = '';
    var c = char.charCodeAt(0);
    if (c < 128) {
        utftext += String.fromCharCode(c);
    }
    else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
    }
    else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
    }
    return utftext;
}
export function uint_add() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var t = Uint32Array.from([0]);
    var x = Uint32Array.from(args);
    x.forEach(function (n) { return (t[0] = t[0] + n); });
    return t[0];
}
export function loop_shift_left(n, bits) {
    return (n << bits) | (n >>> (32 - bits));
}
//# sourceMappingURL=lib.js.map